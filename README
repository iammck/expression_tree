The goal of this project is to aid in learning design pattern concepts using an expression tree processor as the example program.

This project uses a video series presented by Douglas Schmidt available on YouTube as a basis for concept, design, and work flow. Schmidt uses the example to cover several design patterns from the book 'Design Patterns: Elements of Reusable Object-Oriented Software', (Gang of Four).

I shall attempt to follow this series as a guide for writing code that leans heavily on common design patterns. I have not yet seen Schmidt's coded solution to the test case and most of the code samples available through out the videos are written in c++. I shall attempt to write the application using java. Since java uses a garbage collection mechanism for memory management, Schmidt suggests that Bridge pattern may be omitted. To achieve my goals for this exercise, I shall attempt to implement the Bridge pattern along with all the other patterns described in my version of the test case.

I am using a file, argfile to aid the compiling process using the command
	javac @argfile or javac `@argfile in power shell.

The application receives an input expression from the user. It then interprets the expression and forms a binary tree structure. The user can then run several commands upon the structure to print and evaluate the expression. The program has two modes of opperation. The first mode, succinct mode, evaluates a given expression using default parameters. The second, verbose, allows the user to control how the expression is to be evaluated (ie infix, prefix, postfix) and can continue to run until the user quits the application.

-Tree Structure and Access
My first step is to design the appropriate data structures. Each data element in the tree structure is a node, either a branch node or a leaf node. Leaf nodes appear as numbers, while branch nodes are as processes to be performed on its child nodes. A branch node may have one child (ie a unary opperation like negation) or it may have two child nodes. The child nodes of a branch node may be either branch nodes or leaf nodes.

       *
      / \
    /     \
   -       +
     \    / \
      5  3   4

Because of the similarities in the different elements of data and since each data element should be accessible in a uniform way, a Composite pattern is to be used to implement the data model for the application. The Composite pattern consists of the Component, Composite and leaf node elements. The Component is the base class which both composite and leaf nodes extend. A leaf has no children extending component, where as the composite does have child objects extending the component. 
In this case the component is a node, the nodes representing processes are composite (having one ore two child nodes) and the nodes representing numbers are the leaves.  Each node has an item (ie a number, plus, minus, etc), a left and right child node, as well as an accept() method to be used to interact with the node via the visitor pattern.
The implementation of the various elements are distinct, yet should be accessed in a uniform way. The Bridge pattern shall be use to sepparate the abstraction from the implementation. In this way interaction with each node can be accessed in a uniform way.

-ExpressionTree creation

The expression tree is created using the interpreter and builder patterns. The interpreter patter is used to interpreted a string input into interpretable parts. The root of the interpretable parts then builds and expression tree with itself as the root node, then an ExpressionTree object is instantiated with the resulting expression tree. The interpreter input string must be an infix expression The algorithm used seems to be the shunting-yard algorithm. How does one handle pre and post fix notational input? The interpreter class should be able to use the same Symbol derived classes for each input grammer. In addition to this problem I am considering grouping operators and how to implement them. For now the Parenthesis implementation of the Symbol class removes itself from the parsed List. so a phrases like 2*(3-4) and 2*3-4
looks like
		  *			 -
		 / \			/ \
		2   -		       *   4
		   / \		      / \
		  3   4		     2   3
At present in order rebuilding of the input give the same answer 2*3-4 for both trees. The parenthesis should be added when rebuilding into output string or calculated. The structure may be updated to include additional behavior for the parenthesis symbols by including a means of interpreting them in a desireable way into the paresedList then adding relevant node during the build() expression tree phase. The end result may look like 
		  *			
		 / \			
		2   (
		     \
		      )
		     /
		    -		      
		   / \		      
		  3   4
But then there is a problem when going from infix to expression tree, epression tree to prefix, prefix to expression tree, finally expression tree to infix. The parenthesis are lost and the initial equation does not equal the final equation.		  
By always adding a '(' before a left traverse and adding a ')' after the right traverse the expression can be remade with redundant parenthesis. The above trees would be returned as (2*(3-4)) and ((2 * 3) - 4) which return the correct answer. Perhapse then the redundancies can be removed. 
Additionally, iterating through the expression tree (next section) is supposed to happen without knowledge of the location within the tree. Users of the iterator will not know how the tree is being iterated so the iterator must perform the tracking and adding of the parenthesis by returning some kind of parenthesis ComponentNode when needed. 

I think I will proceed as if the user of the iterator is suposed to be able to extrapolate how to to properly reform the expression and its parenthesis. If the user of the iterator is unable to add the parenthesis correctly, the Iterator will make the attempt.

-Iteration
Users of the expression tree should be able to iterate through it in various ways; in order, reverse order, level order. The project should have an iterator base class and use derived classes for each way the expression tree can be iterated.

-visitor pattern.


